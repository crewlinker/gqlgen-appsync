// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"context"
	"encoding/json"
	"fmt"
)

// ResolverFields list all type and field names that are marked as resolvers. This
// is usefull to automate hooking up lambda functions to them in AppSync.
var ResolverFields = []string{
	"Mutation.addSink",
	"Query.version",
	"Query.profile",
	"Query.anotherProfile",
	"Query.node",
	"Query.kitchenSink",
	"Query.sinksOrProfiles",
	"Sink.other",
}

// AppSyncResolve uses the input of a direct appsync resolver and calls the correct method the implementation.
// The return value can be used directly as the result data to be returned to AppSync.
func AppSyncResolve(ctx context.Context, rr ResolverRoot, typeName, fieldName string, args map[string]any, parent []byte) (any, error) {
	ec := executionContext{nil, &executableSchema{resolvers: rr}}

	switch {
	case typeName == "Mutation" && fieldName == "addSink":
		name, err := ec.unmarshalNString2string(ctx, args["name"])
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal argument 'name': %w", err)
		}
		return rr.Mutation().AddSink(ctx, name)
	case typeName == "Query" && fieldName == "version":
		return rr.Query().Version(ctx)
	case typeName == "Query" && fieldName == "profile":
		return rr.Query().Profile(ctx)
	case typeName == "Query" && fieldName == "anotherProfile":
		name, err := ec.unmarshalNString2string(ctx, args["name"])
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal argument 'name': %w", err)
		}
		return rr.Query().AnotherProfile(ctx, name)
	case typeName == "Query" && fieldName == "node":
		id, err := ec.unmarshalNID2int(ctx, args["id"])
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal argument 'id': %w", err)
		}
		return rr.Query().Node(ctx, id)
	case typeName == "Query" && fieldName == "kitchenSink":
		foo, err := ec.unmarshalNString2string(ctx, args["foo"])
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal argument 'foo': %w", err)
		}
		bar, err := ec.unmarshalNBar2githubᚗcomᚋcrewlinkerᚋgqlgenᚑappsyncᚋgraphᚐBar(ctx, args["bar"])
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal argument 'bar': %w", err)
		}
		return rr.Query().KitchenSink(ctx, foo, bar)
	case typeName == "Query" && fieldName == "sinksOrProfiles":
		return rr.Query().SinksOrProfiles(ctx)
	case typeName == "Sink" && fieldName == "other":
		code, err := ec.unmarshalNBar2githubᚗcomᚋcrewlinkerᚋgqlgenᚑappsyncᚋgraphᚐBar(ctx, args["code"])
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal argument 'code': %w", err)
		}

		var obj Sink
		if err = json.Unmarshal(parent, &obj); err != nil {
			return nil, fmt.Errorf("failed to unmarshal parent for nested resolver: %w", err)
		}
		return rr.Sink().Other(ctx, &obj, code)

	default:
		return nil, fmt.Errorf("no resolver for %s.%s", typeName, fieldName)
	}
}

// MarshalJSON implements custom marshalling such that the graphql __typename is always returned. This
// is required since AppSync won't ask for this field when it needs it to determine the type for
// unions and interfaces.
func (this Profile) MarshalJSON() ([]byte, error) {
	type V Profile
	return json.Marshal(struct {
		V
		TypeName string `json:"__typename"`
	}{V(this), "Profile"})
}

// MarshalJSON implements custom marshalling such that the graphql __typename is always returned. This
// is required since AppSync won't ask for this field when it needs it to determine the type for
// unions and interfaces.
func (this Sink) MarshalJSON() ([]byte, error) {
	type V Sink
	return json.Marshal(struct {
		V
		TypeName string `json:"__typename"`
	}{V(this), "Sink"})
}
